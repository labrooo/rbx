if settings.Movement.FlyConfig.toggle then
	-- Toggle flying with F key
	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed then return end

		if input.KeyCode == settings.Movement.FlyConfig.keybind then
			
			if settings.Movement.FlyConfig.runOn == "hold" then
				isFlying = true
				startFlying()
				
				UserInputService.InputEnded:connect(function (input, gpe) 
					if gpe then return end

					if input.KeyCode == settings.Movement.FlyConfig.keybind then
						isFlying = false
						stopFlying()
					end

				end)
			end
			
			if settings.Movement.FlyConfig.runOn == "toggle" then
				toggleFlying()
			end
			

		end
	end)

	function toggleFlying()
		isFlying = not isFlying
		print("Toggling flying:", isFlying)  -- Debug

		if isFlying then
			startFlying()
		else
			stopFlying()
		end
	end

	function startFlying()
	

		-- Enable flying state
		humanoid.PlatformStand = true

		-- Create BodyVelocity for movement
		bodyVelocity = Instance.new("BodyVelocity")
		bodyVelocity.Velocity = Vector3.new(0, 0, 0)
		bodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000)
		bodyVelocity.P = 1000
		bodyVelocity.Parent = character.HumanoidRootPart

		-- Create BodyGyro for rotation
		bodyGyro = Instance.new("BodyGyro")
		bodyGyro.MaxTorque = Vector3.new(50000, 50000, 50000)
		bodyGyro.P = 3000
		bodyGyro.D = 500
		bodyGyro.Parent = character.HumanoidRootPart

		-- Movement update connection
		flyConnection = RunService.RenderStepped:Connect(function(deltaTime)
			if not isFlying or not character:IsDescendantOf(workspace) then
				if flyConnection then
					flyConnection:Disconnect()
					flyConnection = nil
				end
				return
			end

			local direction = Vector3.new(0, 0, 0)
			local rootPart = character:FindFirstChild("HumanoidRootPart")

			if not rootPart then return end

			-- Get movement input
			-- Forward/Backward
			if UserInputService:IsKeyDown(Enum.KeyCode.W) then
				direction = direction + rootPart.CFrame.LookVector
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.S) then
				direction = direction - rootPart.CFrame.LookVector
			end

			-- Left/Right
			if UserInputService:IsKeyDown(Enum.KeyCode.A) then
				direction = direction - rootPart.CFrame.RightVector
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.D) then
				direction = direction + rootPart.CFrame.RightVector
			end

			-- Up/Down
			if UserInputService:IsKeyDown(Enum.KeyCode.Space) then
				direction = direction + Vector3.new(0, 1, 0)
			end
			if UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) then
				direction = direction + Vector3.new(0, -1, 0)
			end

			-- âœ… SAFE: Apply speed with nil check
			if direction.Magnitude > 0 then
				-- Debug: Check FLY_SPEED value
				if FLY_SPEED == nil then
					warn("FLY_SPEED is nil! Defaulting to 50")
					FLY_SPEED = 50
				end

				-- Normalize and apply speed
				direction = direction.Unit * FLY_SPEED  -- This should work now
			end

			-- Apply velocity
			if bodyVelocity then
				bodyVelocity.Velocity = direction
			end

			-- Update rotation to follow camera
			if bodyGyro then
				local camera = workspace.CurrentCamera
				if camera then
					bodyGyro.CFrame = CFrame.new(rootPart.Position, 
						rootPart.Position + camera.CFrame.LookVector)
				end
			end
		end)
	end

	function stopFlying()
		print("Stopping flight")  -- Debug
		humanoid.PlatformStand = false

		-- Clean up physics objects
		if bodyVelocity then
			bodyVelocity:Destroy()
			bodyVelocity = nil
		end

		if bodyGyro then
			bodyGyro:Destroy()
			bodyGyro = nil
		end

		-- Clean up connection
		if flyConnection then
			flyConnection:Disconnect()
			flyConnection = nil
		end
	end

	-- Clean up when character dies
	character.Destroying:Connect(function()
		stopFlying()
	end)

	-- Handle character respawns
	player.CharacterAdded:Connect(function(newCharacter)
		character = newCharacter
		humanoid = newCharacter:WaitForChild("Humanoid")
		stopFlying()  -- Reset flight on new character
	end)

end
